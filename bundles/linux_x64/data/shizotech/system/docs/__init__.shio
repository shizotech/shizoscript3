using std;

local_dir = fileio.file_dir(std.local_executable());

pkgs = fileio.dirs(local_dir + "/shizotech/packages", 0);

for(i = 0; i < pkgs.size(); i++)
{
	std.import(pkgs[i]);
}

shzdocs.load_all_modules();

docs = argv().size() >= 2 ? shzdocs.find_all(argv(1)).sort() : shzdocs.get_all().sort();

repeat_char(c,x)
{
    res = "";
    for(i = 0; i < x; i++)
        res += c;
    return res;
}

color_text(text, color_code)
{
    // ANSI escape codes, if terminal supports
    //return "\033[" + color_code + "m" + text + "\033[0m";
	//Dont use this
	return text;
}

handle_namespace(name, &ns, ns_type = "Namespace")
{
    if(ns.functions.size() == 0 &&
       ns.vars.size() == 0 &&
       ns.children.size() == 0)
        return "";

    // Bold header
    result = "\n\n" + repeat_char("=", 50) + "\n";
    result += color_text(ns_type + ": " + name, "1;34") + "\n"; // bold blue
    result += repeat_char("=", 50) + "\n\n";

    if(ns.vars ?? 0)
    {
        ns.vars.sort();
        // Align arrows
        max_key_len = 0;
        for(i = 0; i < ns.vars.size(); i++)
		{
            if(ns.vars.key(i).length() > max_key_len) 
				max_key_len = ns.vars.key(i).length();
		}
		
        for(i = 0; i < ns.vars.size(); i++)
        {
            key = ns.vars.key(i);
			key = key.substr(key.rfind(".")+1);
            val = ns.vars[i];
            padding = repeat_char(" ", max_key_len - key.length());
			if(ns_type == "Object")
				result += "    " + key + padding + " -> " + "variable\n";
			else
				result += "    " + key + padding + " -> " + val + "\n";
        }

        result += "\n";
    }

    if(ns.functions ?? 0)
    {
        ns.functions.sort();

        for(i = 0; i < ns.functions.size(); i++)
        {
            fn = &ns.functions[i];
            fnname = ns.functions.key(i);

            if(ns_type == "Object")
                fnname = fnname.substr(fnname.find(".") + 1);

            result += repeat_char(" ", 8) + repeat_char("-", 50) + "\n";

            if(ns_type != "Object")
                result += name + ".";

            // Function Signature
            if(fn.params ?? 0)
            {
                result += fnname + "(\n";
                for(j = 0; j < fn.params.size(); j++)
                {
                    result += repeat_char(" ", 4) + fn.params[j];
                    if(j != fn.params.size() - 1)
                        result += ",";
                    result += "\n";
                }
                result += ")";
            }
            else
                result += fnname + "()";

            // Return Class
            if(fn.class_name)
                result += " -> " + fn.class_name;

            result += "\n\n";

            // Description Formatting
            if(fn.description)
            {
                result += "  - " + color_text(fn.description, "33") + "\n"; // yellow
            }

            // Examples
            if(fn.examples)
            {
                result += "\n";
                for(j = 0; j < fn.examples.size(); j++)
                {
                    ex = fn.examples[j];
                    border = repeat_char("-", ex.length() + 4); // dynamic width
                    result += "    +" + border + "+\n";
                    result += "    | " + color_text("Example: " + ex, "32") + " |\n"; // green
                    result += "    +" + border + "+\n\n";
                }
            }
        }
    }

    result += repeat_char(" ", 8) + repeat_char("-", 50) + "\n";

    return result;
}

handle_type(name, &typens)
{
    result = handle_namespace(name, typens, "Object");
    return result;
}

docs.namespaces.sort();
docs.types.sort();

docstr = "";

// Optional Table of Contents
docstr += color_text("=== TABLE OF CONTENTS ===", "1;36") + "\n"; // cyan bold
for(i = 0; i < docs.namespaces.size(); i++)
    docstr += "  - Namespace: " + docs.namespaces.key(i) + "\n";
for(i = 0; i < docs.types.size(); i++)
    docstr += "  - Object Type: " + docs.types.key(i) + "\n";
docstr += "\n";

for(i = 0; i < docs.namespaces.size(); i++)
{
    docstr += handle_namespace(docs.namespaces.key(i), docs.namespaces[i]);
}

if(docs.types.size())
{
    for(i = 0; i < docs.types.size(); i++)
    {
        docstr += handle_type(docs.types.key(i), docs.types[i]);
    }
}

print(docstr);
